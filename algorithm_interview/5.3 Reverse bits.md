## 5.3 Reverse Bits

*Description*:

 Write a program that takes a 64-bit word and returns the 64-bit word consisting of the bits of the input word in reverse order.

For example, if the input is alternating 1s and 0s, i.e., (1010....10)<sub>2</sub>, the output should be alternating 0s and 1s , i.e., (0101.....01)<sub>2</sub>.



***

*Solution*:

1. Brute-force algorithm

   Iterate through the 32 least significant bits of the input, and swap each with the corresponding most significant bit, using, for example, swap.

   ```java
   public static long reverse(long x){
       int i = 0;
       int j = 63;
       while(i < j){
           x = swap(x, i++, j--);
       }
       return x;
   }
   ```

   The time complexity would be O(n). Swap function in 5.2 only cost O(1) time.

2. Look up table

   ```java
   public Solution{
       static int[] precomputedReverse = new int[1 << 16];
       static{
           for(int i = 0; i < (1 << 16); i++){
               precomputedReverse[i] = reverse(i, 15);
           }
       }
       
       static int reverse(int x, int last){
           int i = 0;
           int j = last;
           
           while(i < j){
               x = swap(x, i++, j--);
           }
           return x;
       }
       
       static int swap(int x, int i, int j){
           if(((x >>> i) & 1) != ((x >>> j) & 1)){
               int bitMask = (1 << i) | (1 << j);
               x ^= bitMask;
           }
           return x;
       }
       
       public static int reverse(int n){
           int maskSize = 16;
           int bitMask = 0xFFFF;
           
           return(precomputedReverse[n & bitMask] << 3 * maskSize |
                 precomputedReverse[n >>> maskSize & bitMask] << 2 * maskSize |
                 precomputedReverse[n >>> 2 * maskSize & bitMask] << maskSize |
                 precomputedReverse[n >>> 3 * maskSize & bitMask]);
       }
   }
   ```

   



***

### Leetcode problem

[190. Reverse Bits]( https://github.com/DavidWang1997/wpblog.GitHub.io/issues/146 ).
